(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{427:function(t,e,s){"use strict";s.r(e);var r=s(0),v=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("介绍")]),t._v(" "),e("p",[t._v("Vue双向绑定原理"),e("br")])]),t._v(" "),e("h2",{attrs:{id:"vue-js-的数据双向绑定原理主要基于以下两个机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-js-的数据双向绑定原理主要基于以下两个机制"}},[t._v("#")]),t._v(" Vue.js 的数据双向绑定原理主要基于以下两个机制:")]),t._v(" "),e("ul",[e("li",[t._v("1 数据劫持(响应式系统):vue.js使用object.defineProperty()方法实现对数据的劫持，将每个属性的读取和修改转化为getter和setter函数，从而在数据发生变化时通知依赖该数据的视图进行更新。\nObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。IE8不兼容。\nObject.defineProperty(obj, prop, descriptor)")]),t._v(" "),e("li",[t._v("2 发布订阅模式:vue.js通过订阅者模式实现视图于数据模型之间的绑定。当数据模型发生变化时，会自动通知所有与该数据相关的视图进行更新。")])]),t._v(" "),e("p",[t._v("具体来说，当vue.js实例化时，会对data对象中的所有属性进行劫持，将它们转换为getter和setter函数。当数据发生变化时，setter函数会自动触发一个“依赖管理器”，该管理区会通知所有依赖该数据的视图进行更新。依赖管理器使用的就是发布订阅模式。")]),t._v(" "),e("p",[t._v("对于双向绑定，vue.js实现了一个v-model指令。当用户输入时，v-module指令会监听input事件，并将输入的数据更新到data对象中的对应属性上。同时，由于数据劫持机制的存在，数据的更新会自动触发依赖管理器，从而通知所有依赖该数据的视图进行更新。因此，用户输入的数据会自动更新到页面上。")]),t._v(" "),e("p",[t._v("当vue.js实例的数据发生变化时，视图也会自动的更新。当数据发生变化时，setter函数会通知依赖管理器，然后依赖管理器会遍历所有依赖该数据的视图，对这些视图进行更新。更新视图进行的过程包括了重新渲染dom和执行的相应指令等操作，从而保证视图于数据模型的同步。")])])}),[],!1,null,null,null);e.default=v.exports}}]);